% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xgb.DMatrix.R
\name{xgb.ExternalDMatrix}
\alias{xgb.ExternalDMatrix}
\title{DMatrix from External Data}
\usage{
xgb.ExternalDMatrix(
  data_iterator,
  cache_prefix = tempdir(),
  missing = NA,
  nthread = NULL,
  as_quantile_dmatrix = FALSE,
  ref = NULL,
  max_bin = NULL
)
}
\arguments{
\item{data_iterator}{A data iterator structure as returned by \link{xgb.DataIterator},
which includes an environment shared between function calls, and functions to access
the data in batches on-demand.}

\item{cache_prefix}{The path of cache file, caller must initialize all the directories in this path.}

\item{missing}{A float value to represents missing values in data.

Note that, while functions like \link{xgb.DMatrix} can take a generic \code{NA} and interpret
correctly it for different types like \code{numeric} and \code{integer}, if an \code{NA} value is passed here,
it will not be adapted for different input types.

For example, in R \code{integer} types, missing values are represented by integer number \code{-2147483648}
(since machine 'integer' types do not have an inherent 'NA' value) - hence, if one passes \code{NA},
which is interpreted as a floating-point NaN by 'xgb.ExternalDMatrix', these integer missing values
will not be treated as missing. This should not pose any problem for \code{numeric} types, since they
do have an inheret NaN value.}

\item{nthread}{Number of threads used for creating DMatrix.}

\item{as_quantile_dmatrix}{Whether to create the resulting object as a QuantileDMatrix.}

\item{ref}{The training dataset that provides quantile information, needed when creating
validation/test dataset with \code{xgb.QuantileDMatrix}. Supplying the training DMatrix
as a reference means that the same quantisation applied to the training data is
applied to the validation/test data}

\item{max_bin}{The number of histogram bin, should be consistent with the training parameter
\code{max_bin}.

This is only supported when constructing a QuantileDMatrix.}
}
\value{
A 'DMatrix' object.\itemize{
\item If passing \code{as_quantile_dmatrix=TRUE}, will have additional subclass 'xgb.QuantileDMatrix'
(same as the objects returned by calling \link{xgb.QuantileDMatrix}).
\item If passing \code{as_quantile_dmatrix=FALSE}, will have additional subclass 'xgb.ExternalDMatrix'.
}
}
\description{
Create an xgboost 'DMatrix' or 'QuantileDMatrix' object from external data
supplied by an \link{xgb.DataIterator} object, potentially passed in batches from a
bigger set that might not fit entirely in memory.

Might be created as either a regular 'DMatrix', or as a 'QuantileDMatrix'.\itemize{
\item If created as a regular 'DMatrix', the data is accessed on-demand as needed, multiple
times, without being concatenated (but note that fields like 'label' \bold{will} be concatenated
from multiple calls to the data iterator).
\item If created as a 'QuantileDMatrix', the quantized representation of the full data will
be created in memory, concatenated from multiple calls to the data iterator. The quantized
version is typically lighter than the original data, so there might be cases in which this
representation could potentially fit in memory even if the full data doesn't.
}

For more information, see the guide 'Using XGBoost External Memory Version':
\url{https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html}
}
\examples{
library(xgboost)
data(mtcars)

# this custom environment will be passed to the iterator
# functions at each call. It's up to the user to keep
# track of the iteration number in this environment.
iterator_env <- as.environment(
  list(
    iter = 0,
    x = mtcars[, -1],
    y = mtcars[, 1]
  )
)

# Data is passed in two batches.
# In this example, batches are obtained by subsetting the 'x' variable.
# This is not advantageous to do, since the data is already loaded in memory
# and can be passed in full in one go, but there can be situations in which
# only a subset of the data will fit in the computer's memory, and it can
# be loaded in batches that are accessed one-at-a-time only.
# The 'proxy_handle' is supplied externally when this function is called,
# and it must be passed to 'xgb.ProxyDMatrix' inside of the call.
iterator_next <- function(iterator_env, proxy_handle) {
  curr_iter <- iterator_env[["iter"]]
  if (curr_iter >= 2) {
    # there are only two batches, so this signals end of the stream
    return(0)
  }

  if (curr_iter == 0) {
    x_batch <- iterator_env[["x"]][1:16, ]
    y_batch <- iterator_env[["y"]][1:16]
  } else {
    x_batch <- iterator_env[["x"]][17:32, ]
    y_batch <- iterator_env[["y"]][17:32]
  }

  # Function 'xgb.ProxyDMatrix' must be called manually
  # at each batch with all the appropriate attributes,
  # such as feature names and feature types.
  xgb.ProxyDMatrix(
    proxy_handle = proxy_handle,
    data = x_batch,
    label = y_batch
  )

  iterator_env[["iter"]] <- curr_iter + 1
  # this signals that the stream continues
  return(iterator_env[["iter"]])
}

# This moves the iterator back to its beginning
iterator_reset <- function(iterator_env) {
  iterator_env[["iter"]] <- 0
}

data_iterator <- xgb.DataIterator(
  env = iterator_env,
  f_next = iterator_next,
  f_reset = iterator_reset
)
cache_prefix <- tempdir()

# DMatrix will be constructed from the iterator's batches
dm <- xgb.ExternalDMatrix(data_iterator, cache_prefix, nthread = 1)

# After construction, can be used as a regular DMatrix
params <- list(nthread = 1, objective = "reg:squarederror")
model <- xgb.train(data = dm, nrounds = 2, params = params)

# Predictions can also be called on it, and should be the same
# as if the data were passed differently.
pred_dm <- predict(model, dm)
pred_mat <- predict(model, as.matrix(mtcars[, -1]))
}
\seealso{
\link{xgb.DataIterator}, \link{xgb.ProxyDMatrix}, \link{xgb.QuantileDMatrix}
}
