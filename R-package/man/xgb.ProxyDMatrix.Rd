% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xgb.DMatrix.R
\name{xgb.ProxyDMatrix}
\alias{xgb.ProxyDMatrix}
\title{Proxy DMatrix Updater}
\usage{
xgb.ProxyDMatrix(
  proxy_handle,
  data,
  label = NULL,
  weight = NULL,
  base_margin = NULL,
  feature_names = colnames(data),
  feature_types = NULL,
  group = NULL,
  qid = NULL,
  label_lower_bound = NULL,
  label_upper_bound = NULL,
  feature_weights = NULL,
  enable_categorical = FALSE
)
}
\arguments{
\item{proxy_handle}{A handle to an 'xgb.ProxyDMatrix', which is supplied to the
data iterator 'next' function (passed as argument to \link{xgb.DataIter}),
and which must be updated during the call to a data iterator batch.

This object is not meant to be generated by a user - instead, it gets generated
during a call to \link{xgb.ExternalDMatrix}, and gets passed as a function argument
to the custom user-supplied callback function that forms part of the data iterator.

For more information and for example usage, see the documentation for \link{xgb.ExternalDMatrix}.}

\item{data}{Batch of data belonging to this batch.

Note that not all of the input types supported by \link{xgb.DMatrix} are possible
to pass here. Supported types are:\itemize{
\item \code{matrix}, with types \code{numeric}, \code{integer}, and \code{logical}. Note that for types
\code{integer} and \code{logical}, missing values might not be automatically recognized as
as such - see the documentation for parameter \code{missing} in \link{xgb.ExternalDMatrix}
for details on this.
\item \code{data.frame}, with the same types as supported by 'xgb.DMatrix' and same
conversions applied to it. See the documentation for parameter \code{data} in
\link{xgb.DMatrix} for details on it.
\item CSR matrices, as class \code{dgRMatrix} from package \code{Matrix}.
}}

\item{label}{Label of the training data.}

\item{weight}{Weight for each instance.

Note that, for ranking task, weights are per-group.  In ranking task, one weight
is assigned to each group (not each data point). This is because we
only care about the relative ordering of data points within each group,
so it doesn't make sense to assign weights to individual data points.}

\item{base_margin}{Base margin used for boosting from existing model.

\if{html}{\out{<div class="sourceCode">}}\preformatted{   In the case of multi-output models, one can also pass multi-dimensional base_margin.
}\if{html}{\out{</div>}}}

\item{feature_names}{Set names for features. Overrides column names in data
frame and matrix.

\if{html}{\out{<div class="sourceCode">}}\preformatted{   Note: columns are not referenced by name when calling `predict`, so the column order there
   must be the same as in the DMatrix construction, regardless of the column names.
}\if{html}{\out{</div>}}}

\item{feature_types}{Set types for features.

If \code{data} is a \code{data.frame} and passing \code{enable_categorical=TRUE}, the types will be deduced
automatically from the column types.

Otherwise, one can pass a character vector with the same length as number of columns in \code{data},
with the following possible values:\itemize{
\item "c", which represents categorical columns.
\item "q", which represents numeric columns.
\item "int", which represents integer columns.
\item "i", which represents logical (boolean) columns.
}

Note that, while categorical types are treated differently from the rest for model fitting
purposes, the other types do not influence the generated model, but have effects in other
functionalities such as feature importances.}

\item{group}{Group size for all ranking group.}

\item{qid}{Query ID for data samples, used for ranking.}

\item{label_lower_bound}{Lower bound for survival training.}

\item{label_upper_bound}{Upper bound for survival training.}

\item{feature_weights}{Set feature weights for column sampling.}

\item{enable_categorical}{Experimental support of specializing for categorical features.

\if{html}{\out{<div class="sourceCode">}}\preformatted{                      If passing 'TRUE' and 'data' is a data frame,
                      columns of categorical types will automatically
                      be set to be of categorical type (feature_type='c') in the resulting DMatrix.

                      If passing 'FALSE' and 'data' is a data frame with categorical columns,
                      it will result in an error being thrown.

                      If 'data' is not a data frame, this argument is ignored.

                      JSON/UBJSON serialization format is required for this.
}\if{html}{\out{</div>}}}
}
\value{
Always returns value 'TRUE'.
}
\description{
Helper function to supply data in batches of a data iterator
when constructing a DMatrix from external memory through \link{xgb.ExternalDMatrix}.

This function is \bold{only} meant to be called inside of a callback function (which is
passed as argument to function \link{xgb.DataIter} to construct a data iterator)
when constructing a DMatrix through external memory - otherwise, one should call
\link{xgb.DMatrix} or \link{xgb.QuantileDMatrix}.
Class 'xgb.ProxyDMatrix' is not meant to be constructed directly by a user, only usage
is internal inside callback functions that supply streaming data in batches, and its
construction is handled internally as part of the DMatrix creation.
}
\seealso{
\link{xgb.DataIter}, \link{xgb.ExternalDMatrix}.
}
